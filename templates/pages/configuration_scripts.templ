package pages

templ ConfigurationScripts() {
	<script>
	// Global variable to track if we're editing
	let editingServerId = null;
	let editingScheduleName = null;

	// Server Management Functions
	async function saveServer() {
		const form = document.getElementById('server-form');
		const databases = document.getElementById('serverDatabases').value
			.split(',')
			.map(db => db.trim())
			.filter(db => db.length > 0);

		const serverData = {
			name: document.getElementById('serverName').value,
			type: document.getElementById('serverType').value,
			host: document.getElementById('serverHost').value,
			port: document.getElementById('serverPort').value || '',
			username: document.getElementById('serverUsername').value,
			password: document.getElementById('serverPassword').value,
			include_databases: databases
		};

		try {
			// First, test the connection
			const testButton = document.querySelector('#addServerModal .btn-primary');
			testButton.disabled = true;
			testButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Testing connection...';
			
			const testResponse = await fetch('/api/servers/test', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(serverData)
			});

			if (!testResponse.ok) {
				const error = await testResponse.json();
				showToast('Connection Failed', error.message || 'Unable to connect to database server', 'danger');
				return;
			}

			// Connection successful, now save the server
			testButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Saving...';
			
			const response = await fetch('/api/servers', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(serverData)
			});

			if (response.ok) {
				// Close modal and reload page
				bootstrap.Modal.getInstance(document.getElementById('addServerModal')).hide();
				showToast('Success', 'Server saved successfully', 'success');
				setTimeout(() => location.reload(), 1000);
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to save server', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to save server: ' + error.message, 'danger');
		} finally {
			const testButton = document.querySelector('#addServerModal .btn-primary');
			testButton.disabled = false;
			testButton.innerHTML = 'Save Server';
		}
	}

	async function deleteServer(serverName) {
		if (!confirm('Are you sure you want to delete this server?')) {
			return;
		}

		try {
			const response = await fetch('/api/servers/delete', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ name: serverName })
			});

			if (response.ok) {
				showToast('Success', 'Server deleted successfully', 'success');
				setTimeout(() => location.reload(), 1000);
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to delete server', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to delete server: ' + error.message, 'danger');
		}
	}

	// Storage Management Functions
	async function saveLocalStorage(event) {
		event.preventDefault();

		const storageData = {
			enabled: document.getElementById('localEnabled').checked,
			backup_directory: document.getElementById('backupDirectory').value,
			organization_strategy: document.getElementById('localOrgStrategy').value
		};

		try {
			// For now, show a message that local storage is configured via YAML
			showToast('Info', 'Local storage configuration is managed via YAML file', 'info');
		} catch (error) {
			showToast('Error', 'Failed to save: ' + error.message, 'danger');
		}
	}

	async function saveS3Storage(event) {
		event.preventDefault();

		const storageData = {
			enabled: document.getElementById('s3Enabled').checked,
			bucket: document.getElementById('s3Bucket').value,
			region: document.getElementById('s3Region').value,
			endpoint: document.getElementById('s3Endpoint').value,
			access_key: document.getElementById('s3AccessKey').value,
			secret_key: document.getElementById('s3SecretKey').value,
			prefix: document.getElementById('s3Prefix').value,
			use_ssl: document.getElementById('s3UseSSL').checked
		};

		try {
			const response = await fetch('/api/s3', {
				method: 'PUT',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(storageData)
			});

			if (response.ok) {
				showToast('Success', 'S3 storage configuration saved', 'success');
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to save S3 configuration', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to save: ' + error.message, 'danger');
		}
	}

	async function testS3Connection() {
		const button = event.target;
		button.disabled = true;
		button.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Testing...';

		try {
			const response = await fetch('/api/s3/test', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					bucket: document.getElementById('s3Bucket').value,
					region: document.getElementById('s3Region').value,
					endpoint: document.getElementById('s3Endpoint').value,
					access_key: document.getElementById('s3AccessKey').value,
					secret_key: document.getElementById('s3SecretKey').value,
					use_ssl: document.getElementById('s3UseSSL').checked
				})
			});

			const result = await response.json();
			if (response.ok) {
				showToast('Success', result.message || 'S3 connection test successful', 'success');
			} else {
				showToast('Error', result.error || 'S3 connection test failed', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Connection test failed: ' + error.message, 'danger');
		} finally {
			button.disabled = false;
			button.innerHTML = '<i data-feather="check-circle"></i> Test Connection';
			feather.replace();
		}
	}

	// Schedule Management Functions
	async function saveSchedule() {
		const scheduleData = {
			id: editingScheduleName,  // Will be null for new schedules
			name: document.getElementById('scheduleType').value,
			backupType: document.getElementById('scheduleType').value,
			cronExpression: document.getElementById('scheduleCron').value,
			enabled: true,
			localStorage: {
				enabled: document.getElementById('localRetentionEnabled').checked,
				duration: document.getElementById('localRetentionDuration').value || '24h',
				keepForever: false
			},
			s3Storage: {
				enabled: document.getElementById('s3RetentionEnabled').checked,
				duration: document.getElementById('s3RetentionDuration').value || '24h',
				keepForever: false
			}
		};

		try {
			const response = await fetch('/api/schedules', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(scheduleData)
			});

			if (response.ok) {
				bootstrap.Modal.getInstance(document.getElementById('addScheduleModal')).hide();
				showToast('Success', 'Schedule saved successfully', 'success');
				setTimeout(() => location.reload(), 1000);
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to save schedule', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to save schedule: ' + error.message, 'danger');
		}
	}

	function editSchedule(backupType, schedule) {
		// Load the schedule data into the modal
		editingScheduleName = backupType;
		
		document.getElementById('scheduleType').value = backupType;
		document.getElementById('scheduleCron').value = schedule.Schedule;
		document.getElementById('localRetentionEnabled').checked = schedule.Local.Enabled;
		document.getElementById('localRetentionDuration').value = schedule.Local.Retention.Duration;
		document.getElementById('s3RetentionEnabled').checked = schedule.S3.Enabled;
		document.getElementById('s3RetentionDuration').value = schedule.S3.Retention.Duration;
		
		// Update modal title
		document.querySelector('#addScheduleModal .modal-title').textContent = 'Edit Backup Schedule';
		
		// Show the modal
		const modal = new bootstrap.Modal(document.getElementById('addScheduleModal'));
		modal.show();
	}

	async function deleteSchedule(scheduleName) {
		if (!confirm('Are you sure you want to delete this schedule?')) {
			return;
		}

		try {
			const response = await fetch(`/api/schedules/delete?id=${scheduleName}`, {
				method: 'POST'
			});

			if (response.ok) {
				showToast('Success', 'Schedule deleted successfully', 'success');
				setTimeout(() => location.reload(), 1000);
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to delete schedule', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to delete schedule: ' + error.message, 'danger');
		}
	}

	// MySQL Options Management
	async function showMySQLOptions(serverName) {
		try {
			const url = serverName ? `/api/mysql-options/${serverName}` : '/api/mysql-options';
			const response = await fetch(url);
			
			if (!response.ok) {
				throw new Error('Failed to fetch MySQL options');
			}

			const options = await response.json();
			
			// Create and show a modal with MySQL options
			const modalHtml = `
				<div class="modal fade" id="mysqlOptionsModal" tabindex="-1">
					<div class="modal-dialog">
						<div class="modal-content">
							<div class="modal-header">
								<h5 class="modal-title">MySQL Options${serverName ? ' for ' + serverName : ' (Global)'}</h5>
								<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
							</div>
							<div class="modal-body">
								<form id="mysql-options-form">
									<div class="mb-3">
										<label for="mysqlOptions" class="form-label">Additional mysqldump Options</label>
										<textarea class="form-control" id="mysqlOptions" rows="3">${options.additional_options || ''}</textarea>
										<small class="form-text text-muted">Enter one option per line (e.g., --single-transaction)</small>
									</div>
								</form>
							</div>
							<div class="modal-footer">
								<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
								<button type="button" class="btn btn-primary" onclick="saveMySQLOptions('${serverName || ''}')">Save Options</button>
							</div>
						</div>
					</div>
				</div>
			`;

			// Remove existing modal if any
			const existingModal = document.getElementById('mysqlOptionsModal');
			if (existingModal) {
				existingModal.remove();
			}

			// Add modal to body and show it
			document.body.insertAdjacentHTML('beforeend', modalHtml);
			const modal = new bootstrap.Modal(document.getElementById('mysqlOptionsModal'));
			modal.show();

		} catch (error) {
			showToast('Error', 'Failed to load MySQL options: ' + error.message, 'danger');
		}
	}

	async function saveMySQLOptions(serverName) {
		const options = document.getElementById('mysqlOptions').value
			.split('\n')
			.map(opt => opt.trim())
			.filter(opt => opt.length > 0);

		try {
			const url = serverName ? `/api/mysql-options/${serverName}` : '/api/mysql-options';
			const response = await fetch(url, {
				method: 'PUT',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					additional_options: options.join(' ')
				})
			});

			if (response.ok) {
				bootstrap.Modal.getInstance(document.getElementById('mysqlOptionsModal')).hide();
				showToast('Success', 'MySQL options saved successfully', 'success');
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to save MySQL options', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to save: ' + error.message, 'danger');
		}
	}

	// PostgreSQL Options Management
	async function showPostgreSQLOptions(serverName) {
		try {
			const url = serverName ? `/api/postgresql-options/${serverName}` : '/api/postgresql-options';
			const response = await fetch(url);
			
			if (!response.ok) {
				throw new Error('Failed to fetch PostgreSQL options');
			}

			const options = await response.json();
			
			// Create and show a modal with PostgreSQL options
			const modalHtml = `
				<div class="modal fade" id="postgresqlOptionsModal" tabindex="-1">
					<div class="modal-dialog">
						<div class="modal-content">
							<div class="modal-header">
								<h5 class="modal-title">PostgreSQL Options${serverName ? ' for ' + serverName : ' (Global)'}</h5>
								<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
							</div>
							<div class="modal-body">
								<form id="postgresql-options-form">
									<div class="mb-3">
										<label for="postgresqlOptions" class="form-label">Additional pg_dump Options</label>
										<textarea class="form-control" id="postgresqlOptions" rows="3">${options.additional_options || ''}</textarea>
										<small class="form-text text-muted">Enter one option per line (e.g., --verbose)</small>
									</div>
									<div class="mb-3">
										<label for="postgresqlFormat" class="form-label">Dump Format</label>
										<select class="form-select" id="postgresqlFormat">
											<option value="plain" ${options.dump_format === 'plain' ? 'selected' : ''}>Plain SQL</option>
											<option value="custom" ${options.dump_format === 'custom' ? 'selected' : ''}>Custom</option>
											<option value="directory" ${options.dump_format === 'directory' ? 'selected' : ''}>Directory</option>
											<option value="tar" ${options.dump_format === 'tar' ? 'selected' : ''}>Tar</option>
										</select>
									</div>
									<div class="mb-3">
										<label for="postgresqlCompression" class="form-label">Compression Level (0-9)</label>
										<input type="number" class="form-control" id="postgresqlCompression" min="0" max="9" value="${options.compression_level || 0}">
									</div>
								</form>
							</div>
							<div class="modal-footer">
								<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
								<button type="button" class="btn btn-primary" onclick="savePostgreSQLOptions('${serverName || ''}')">Save Options</button>
							</div>
						</div>
					</div>
				</div>
			`;

			// Remove existing modal if any
			const existingModal = document.getElementById('postgresqlOptionsModal');
			if (existingModal) {
				existingModal.remove();
			}

			// Add modal to body and show it
			document.body.insertAdjacentHTML('beforeend', modalHtml);
			const modal = new bootstrap.Modal(document.getElementById('postgresqlOptionsModal'));
			modal.show();

		} catch (error) {
			showToast('Error', 'Failed to load PostgreSQL options: ' + error.message, 'danger');
		}
	}

	async function savePostgreSQLOptions(serverName) {
		const options = document.getElementById('postgresqlOptions').value
			.split('\n')
			.map(opt => opt.trim())
			.filter(opt => opt.length > 0);

		const data = {
			additional_options: options.join(' '),
			dump_format: document.getElementById('postgresqlFormat').value,
			compression_level: parseInt(document.getElementById('postgresqlCompression').value)
		};

		try {
			const url = serverName ? `/api/postgresql-options/${serverName}` : '/api/postgresql-options';
			const response = await fetch(url, {
				method: 'PUT',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(data)
			});

			if (response.ok) {
				bootstrap.Modal.getInstance(document.getElementById('postgresqlOptionsModal')).hide();
				showToast('Success', 'PostgreSQL options saved successfully', 'success');
			} else {
				const error = await response.json();
				showToast('Error', error.error || 'Failed to save PostgreSQL options', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Failed to save: ' + error.message, 'danger');
		}
	}

	// Test server connection
	async function testServerConnection(server) {
		const button = event.target.closest('button');
		button.disabled = true;
		button.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

		try {
			const response = await fetch('/api/servers/test', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({
					name: server.name,
					type: server.type,
					host: server.host,
					port: server.port || '',
					username: server.username,
					password: server.password || ''
				})
			});

			const result = await response.json();
			if (response.ok) {
				showToast('Success', result.message || 'Connection successful', 'success');
			} else {
				showToast('Error', result.error || 'Connection failed', 'danger');
			}
		} catch (error) {
			showToast('Error', 'Connection test failed: ' + error.message, 'danger');
		} finally {
			button.disabled = false;
			button.innerHTML = '<i data-feather="check-circle"></i>';
			feather.replace();
		}
	}

	// Helper function to show toast notifications
	function showToast(title, message, type) {
		const toastHtml = `
			<div class="toast align-items-center text-white bg-${type} border-0" role="alert">
				<div class="d-flex">
					<div class="toast-body">
						<strong>${title}:</strong> ${message}
					</div>
					<button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
				</div>
			</div>
		`;
		
		// Create toast container if it doesn't exist
		let toastContainer = document.getElementById('toast-container');
		if (!toastContainer) {
			toastContainer = document.createElement('div');
			toastContainer.id = 'toast-container';
			toastContainer.className = 'position-fixed bottom-0 end-0 p-3';
			toastContainer.style.zIndex = '11';
			document.body.appendChild(toastContainer);
		}

		toastContainer.insertAdjacentHTML('beforeend', toastHtml);
		
		const toastElement = toastContainer.lastElementChild;
		const toast = new bootstrap.Toast(toastElement);
		toast.show();
		
		// Remove toast element after it's hidden
		toastElement.addEventListener('hidden.bs.toast', () => {
			toastElement.remove();
		});
	}

	// Initialize form handlers when DOM is loaded
	document.addEventListener('DOMContentLoaded', function() {
		// Local storage form
		const localForm = document.getElementById('local-storage-form');
		if (localForm) {
			localForm.addEventListener('submit', saveLocalStorage);
		}

		// S3 storage form
		const s3Form = document.getElementById('s3-storage-form');
		if (s3Form) {
			s3Form.addEventListener('submit', saveS3Storage);
		}

		// Load current S3 configuration when page loads
		loadS3Config();

		// Reset modal forms when closed
		const serverModal = document.getElementById('addServerModal');
		if (serverModal) {
			serverModal.addEventListener('hidden.bs.modal', function () {
				document.getElementById('server-form').reset();
				editingServerId = null;
			});
		}

		const scheduleModal = document.getElementById('addScheduleModal');
		if (scheduleModal) {
			scheduleModal.addEventListener('hidden.bs.modal', function () {
				document.getElementById('schedule-form').reset();
				editingScheduleName = null;
			});
		}

		// Set default ports when server type changes
		const serverTypeSelect = document.getElementById('serverType');
		if (serverTypeSelect) {
			serverTypeSelect.addEventListener('change', function() {
				const portInput = document.getElementById('serverPort');
				if (this.value === 'mysql') {
					portInput.value = '3306';
				} else if (this.value === 'postgresql') {
					portInput.value = '5432';
				}
			});
		}
	});

	// Load current S3 configuration
	async function loadS3Config() {
		try {
			const response = await fetch('/api/s3');
			if (response.ok) {
				const config = await response.json();
				
				// Update form fields with current values
				document.getElementById('s3Enabled').checked = config.enabled;
				document.getElementById('s3Bucket').value = config.bucket || '';
				document.getElementById('s3Region').value = config.region || '';
				document.getElementById('s3Endpoint').value = config.endpoint || '';
				document.getElementById('s3AccessKey').value = config.access_key || '';
				document.getElementById('s3SecretKey').value = config.secret_key || '';
				document.getElementById('s3Prefix').value = config.prefix || '';
				document.getElementById('s3UseSSL').checked = config.use_ssl !== false;
			}
		} catch (error) {
			console.error('Failed to load S3 configuration:', error);
		}
	}

	// Convert cron expression to human readable format
	function cronToHuman(cron) {
		// Simple conversion for common patterns
		const patterns = {
			'0 * * * *': 'Every hour',
			'0 0 * * *': 'Daily at midnight',
			'0 2 * * *': 'Daily at 2:00 AM',
			'0 3 * * 0': 'Weekly on Sunday at 3:00 AM',
			'0 0 * * 0': 'Weekly on Sunday at midnight',
			'0 0 1 * *': 'Monthly on the 1st at midnight'
		};
		
		return patterns[cron] || cron;
	}

	// Validate cron expression
	function validateCron(cron) {
		const parts = cron.split(' ');
		if (parts.length !== 5) {
			return false;
		}
		// Basic validation - could be enhanced
		return true;
	}
	</script>
}